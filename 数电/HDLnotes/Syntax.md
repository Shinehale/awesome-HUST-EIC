## 模块

模块由关键词 module ..... endmodule 确定

```verilog
module Name( Parameters );
// signal statement
// functional description
endmodule
```

要求：

- 模块名具有意义 （沿用驼峰命名法）
- 一个.v文件只有一个模块



## 数据类型

### 常量

-  数字：` <位宽> <类型> <数字>`  eg: 8' b 1100_0010
- X和Z值 ： X：不定值；Z：高阻 （同也可用？表示）
- 负数 ： 如：-8’d5 ，减号在最前面。

### 参数型

Verilog模块中可使用parameter来定义一个标识符来代表一个常量。

parameter SIZE = 15;

|              | 作用域                      | 常用方式                         | 语法                             |
| ------------ | --------------------------- | -------------------------------- | -------------------------------- |
| define宏定义 | 整个工程；可跨文件、跨模块  | 全局定义，宏定义单独写一个文件.v | `include “para.v”`define SIZE 15 |
| parameter    | parameter声明所在的模块内部 | 跨模块传递参数                   | parameter SIZE = 15;             |
| localparam   | 模块内部                    | 内部状态机定义                   | localparam SIZE = 15;            |

### 变量

#### wire类型

①线网型，输入输出信号默认为wire型，**同时输入信号只能是wire型**。

②模块间端口连接，信号都定义为wire型，即进行电路连线。

③wire信号定义： wire [7:0] a;

④wire信号赋值：只能使用assign进行连续赋值（阻塞赋值 “=”）：

assign a = b & c;

#### reg类型

①寄存器是数据储存单元的抽象。寄存器数据类型的关键字是reg。但reg型不一定综合成寄存器，具体还要看设计电路。

②always块中的变量必须定义为reg型，使用非阻塞赋值“<=”。

③reg型数据定义： reg [7:0] a;

④reg型数据可以赋正值，也可以赋负值。但当一个reg型数据是一个表达式中的操作数时，它的值被当作是无符号值，即正值。

⑤reg型数据的缺省值为不定值X。

#### memory类型

memory型数据是通过扩展reg型数据的地址范围来生成的。其格式如下：

reg [n-1:0] 存储器名[m-1:0]；

eg :  reg [7,0] memA[255:0];

这个例子定义了一个名为mema的存储器，该存储器有256个8位的存储器。该存储器的地址范围是0到255。注意：对存储器进行地址索引的表达式必须是常数表达式  

#### 运算符

1) 算术运算符(+,－,×，/,％)

2) 赋值运算符(=,<=)

3) 关系运算符(>,<,>=,<=)

4) 逻辑运算符(&&,||,!)

5) 条件运算符(?:)

6) 位运算符(~,|,^,&,^~)

7) 移位运算符(<<,>>)

8) 拼接运算符({ })

9) 其它

在Verilog HDL语言中运算符所带的操作数是不同的，按其所带操作数的个数运算符可分为三种:

1) 单目运算符(unary operator):可以带一个操作数,操作数放在运算符的右边。

2) 二目运算符(binary operator):可以带二个操作数,操作数放在运算符的两边。

3) 三目运算符(ternary operator):可以带三个操作,这三个操作数用三目运算符分隔开。



## 赋值语句和块语句

### 赋值语句

在Verilog HDL语言中，信号有两种赋值方式：

(1)非阻塞(Non_Blocking)赋值方式( 如 b <= a; )

1) 块结束后才完成赋值操作。

2) b的值并不是立刻就改变的。

3) 这是一种比较常用的赋值方法。（特别在编写可综合模块时）

(2)阻塞(Blocking)赋值方式( 如 b = a; )

1) 赋值语句执行完后,块才结束。

2) b的值在赋值语句执行完后立刻就改变的。

3) 可能会产生意想不到的结果



设计时，遵循以下规则：

1. always块中使用非阻塞赋值
2. assign使用阻塞赋值



### 块语句

**顺序块：** （顺序执行）

```verilog
begin
语句1；
语句2；
...
end
```

**并行块：** （同时执行）

```verilog
fork
语句1；
语句2；
...
end
```

注：begin/fork后可以加 “:块名”



### 条件语句和循环语句

基本同C语言，较容易理解，不多介绍

**条件语句**

if..else （可嵌套）

```verilog
if(条件)
语句1；
else
语句2；
```

case

```verilog
case(变量)
情况1： 语句1；
情况2： 语句2；
endcase
```

**循环语句**

```verilog
integer i;
for(i=0;i<10;i=i+1)
a[i]	<=	i;
```



## 结构说明语句

Verilog语言中的任何过程模块都从属于以下四种结构的说明语句。

1) initial说明语句

2) always说明语句

3) task说明语句

4) function说明语句

这里只介绍always：

always语句在仿真过程中是不断重复执行的。

其声明格式如下：

`always <时序控制> <语句>`

always 的时间控制可以是沿触发也可以是电平触发的，可以单个信号也可以多个信号，中间需要用关键字 or 连接。

```verilog
always @(posedge clock or posedge reset) //由两个沿触发的时序逻辑
begin
……
end

//组合逻辑直接使用*代替敏感点平，避免遗漏
always @(*) //由多个电平触发的组合逻辑
begin
……
end
```











- 
- 
-  
-  